"""
Code Sandbox for Safe Execution of Dynamic Code.

Provides a restricted execution environment for code generated by
the external planner. This is critical for open-ended planning where
the planner can create arbitrary code actions.

Security measures:
1. Restricted builtins (no file I/O, no imports of dangerous modules)
2. Timeout enforcement
3. Memory limits (via resource module on Unix)
4. Namespace isolation
"""

import ast
import multiprocessing
import queue
import sys
import time
import traceback
from dataclasses import dataclass, field
from typing import Any

# Safe builtins whitelist
SAFE_BUILTINS = {
    # Basic types
    "True": True,
    "False": False,
    "None": None,
    # Type constructors
    "bool": bool,
    "int": int,
    "float": float,
    "str": str,
    "list": list,
    "dict": dict,
    "set": set,
    "tuple": tuple,
    "frozenset": frozenset,
    # Basic functions
    "abs": abs,
    "all": all,
    "any": any,
    "bin": bin,
    "chr": chr,
    "divmod": divmod,
    "enumerate": enumerate,
    "filter": filter,
    "format": format,
    "hex": hex,
    "isinstance": isinstance,
    "issubclass": issubclass,
    "iter": iter,
    "len": len,
    "map": map,
    "max": max,
    "min": min,
    "next": next,
    "oct": oct,
    "ord": ord,
    "pow": pow,
    "range": range,
    "repr": repr,
    "reversed": reversed,
    "round": round,
    "slice": slice,
    "sorted": sorted,
    "sum": sum,
    "zip": zip,
}

# Modules that can be imported
ALLOWED_MODULES = {
    "math",
    "json",
    "re",
    "datetime",
    "collections",
    "itertools",
    "functools",
    "operator",
    "string",
    "random",
    "statistics",
    "decimal",
    "fractions",
    "time", # Added for testing and timing
}

# Dangerous AST nodes to block
BLOCKED_AST_NODES = {
    ast.Import,
    ast.ImportFrom,
    ast.Global,
    ast.Nonlocal,
}


class CodeSandboxError(Exception):
    """Error during sandboxed code execution."""
    pass


class TimeoutError(CodeSandboxError):
    """Code execution timed out."""
    pass


class SecurityError(CodeSandboxError):
    """Code contains potentially dangerous operations."""
    pass


@dataclass
class SandboxResult:
    """Result of sandboxed code execution."""
    success: bool
    result: Any = None
    error: str | None = None
    stdout: str = ""
    variables: dict[str, Any] = field(default_factory=dict)
    execution_time_ms: int = 0


class RestrictedImporter:
    """Custom importer that only allows whitelisted modules."""

    def __init__(self, allowed_modules: set[str]):
        self.allowed_modules = allowed_modules
        self._cache: dict[str, Any] = {}

    def __call__(self, name: str, *args, **kwargs):
        if name not in self.allowed_modules:
            raise SecurityError(f"Import of module '{name}' is not allowed")

        if name not in self._cache:
            import importlib
            self._cache[name] = importlib.import_module(name)

        return self._cache[name]


def _run_in_process(
    code: str,
    inputs: dict[str, Any],
    extract_vars: list[str],
    allowed_modules: set[str],
    safe_builtins: dict[str, Any],
    result_queue: multiprocessing.Queue,
    preload_modules: list[str] | None = None,
) -> None:
    """
    Worker function to run code in a separate process.
    Must be top-level for pickling on Windows.
    """
    import io

    # Capture stdout
    old_stdout = sys.stdout
    sys.stdout = captured_stdout = io.StringIO()
    
    start_time = time.time()
    
    # Prepare namespace
    input_vars = inputs or {}
    extract_vars = extract_vars or []
    preload_modules = preload_modules or []
    
    importer = RestrictedImporter(allowed_modules)
    builtins_copy = dict(safe_builtins)
    builtins_copy["__import__"] = importer
    
    namespace = {
        "__builtins__": builtins_copy,
    }

    # Preload requested modules (check allowance first)
    for mod_name in preload_modules:
        if mod_name in allowed_modules:
            try:
                import importlib
                namespace[mod_name] = importlib.import_module(mod_name)
            except ImportError:
                pass
    
    namespace.update(input_vars)

    try:
        # Compile and execute
        compiled = compile(code, "<sandbox>", "exec")
        exec(compiled, namespace)
        
        execution_time_ms = int((time.time() - start_time) * 1000)
        
        # Extract requested variables
        extracted = {}
        for var in extract_vars:
            if var in namespace:
                extracted[var] = namespace[var]
        
        # Also extract any new variables 
        for key, value in namespace.items():
            if key not in input_vars and key not in safe_builtins and not key.startswith("_") and key != "__import__":
                # Try to pickle the value, if fails, use representation
                try:
                    # Basic pickle check simulation (queue put will fail if not picklable)
                    pass 
                except:
                    pass
                extracted[key] = value

        result = SandboxResult(
            success=True,
            result=namespace.get("result"),
            stdout=captured_stdout.getvalue(),
            variables=extracted,
            execution_time_ms=execution_time_ms,
        )
        

    except BaseException as e:
        # Catch SystemExit and other BaseExceptions too
        # traceback.print_exc() # Debug
        result = SandboxResult(
            success=False,
            error=f"{type(e).__name__}: {e}",
            stdout=captured_stdout.getvalue(),
            execution_time_ms=int((time.time() - start_time) * 1000),
        )
    finally:
        sys.stdout = old_stdout
        try:
            result_queue.put(result)
        except Exception:
            # If result wasn't created (unlikely now) or queue is closed
            pass



class CodeValidator:
    """Validates code for safety before execution."""

    def __init__(self, blocked_nodes: set[type] | None = None):
        self.blocked_nodes = blocked_nodes or BLOCKED_AST_NODES

    def validate(self, code: str) -> list[str]:
        """
        Validate code and return list of issues.

        Returns empty list if code is safe.
        """
        issues = []

        try:
            tree = ast.parse(code)
        except SyntaxError as e:
            return [f"Syntax error: {e}"]

        for node in ast.walk(tree):
            # Check for blocked node types
            if type(node) in self.blocked_nodes:
                lineno = getattr(node, "lineno", "?")
                issues.append(f"Blocked operation: {type(node).__name__} at line {lineno}")

            # Check for dangerous attribute access
            if isinstance(node, ast.Attribute):
                if node.attr.startswith("_"):
                    issues.append(
                        f"Access to private attribute '{node.attr}' at line {node.lineno}"
                    )

            # Check for exec/eval calls
            if isinstance(node, ast.Call):
                if isinstance(node.func, ast.Name):
                    if node.func.id in ("exec", "eval", "compile", "__import__"):
                        issues.append(
                            f"Blocked function call: {node.func.id} at line {node.lineno}"
                        )

        return issues


class CodeSandbox:
    """
    Sandboxed environment for executing dynamic code.

    Usage:
        sandbox = CodeSandbox(timeout_seconds=5)
        result = sandbox.execute(
            code="x = 1 + 2\\nresult = x * 3",
            inputs={"multiplier": 2},
        )
        if result.success:
            print(result.variables["result"])  # 6
    """

    def __init__(
        self,
        timeout_seconds: int = 10,
        allowed_modules: set[str] | None = None,
        safe_builtins: dict[str, Any] | None = None,
    ):
        self.timeout_seconds = timeout_seconds
        self.allowed_modules = allowed_modules or ALLOWED_MODULES
        self.safe_builtins = safe_builtins or SAFE_BUILTINS
        self.validator = CodeValidator()
        self.importer = RestrictedImporter(self.allowed_modules)

    def execute(
        self,
        code: str,
        inputs: dict[str, Any] | None = None,
        extract_vars: list[str] | None = None,
        preload_modules: list[str] | None = None,
    ) -> SandboxResult:
        """
        Execute code in sandbox (multiprocessing for safe timeouts).
        """
        inputs = inputs or {}
        extract_vars = extract_vars or []
        preload_modules = preload_modules or []

        # Validate code first
        issues = self.validator.validate(code)
        if issues:
            return SandboxResult(
                success=False,
                error=f"Code validation failed: {'; '.join(issues)}",
            )
            
        # Create queue for result
        result_queue = multiprocessing.Queue()
        
        # Create and start process
        process = multiprocessing.Process(
            target=_run_in_process,
            args=(
                code,
                inputs,
                extract_vars,
                self.allowed_modules,
                self.safe_builtins,
                result_queue,
                preload_modules,
            )
        )
        
        process.start()
        
        
        # Wait for result with timeout to avoid deadlock on large payloads
        # (If we join() first, the child might be blocked writing to a full pipe)
        try:
            result = result_queue.get(timeout=self.timeout_seconds)
            process.join() # Should be immediate as child has finished putting
            return result
        except queue.Empty:
            # Timeout!
            if process.is_alive():
                process.terminate()
            process.join() # cleanup
            return SandboxResult(
                success=False,
                error=f"Code execution timed out after {self.timeout_seconds} seconds",
                execution_time_ms=self.timeout_seconds * 1000,
            )
        except Exception as e:
            if process.is_alive():
                 process.terminate()
            process.join()
            return SandboxResult(
                success=False,
                error=f"Failed to retrieve result: {e}",
            )

    def execute_expression(
        self,
        expression: str,
        inputs: dict[str, Any] | None = None,
    ) -> SandboxResult:
        """
        Execute a single expression.
        """
        # Convert expression to code assignment
        code = f"result = {expression}"
        return self.execute(code, inputs, extract_vars=["result"])



# Singleton instance with default settings
default_sandbox = CodeSandbox()


def safe_exec(
    code: str,
    inputs: dict[str, Any] | None = None,
    timeout_seconds: int = 10,
) -> SandboxResult:
    """
    Convenience function for safe code execution.

    Args:
        code: Python code to execute
        inputs: Variables to inject
        timeout_seconds: Max execution time

    Returns:
        SandboxResult
    """
    sandbox = CodeSandbox(timeout_seconds=timeout_seconds)
    return sandbox.execute(code, inputs)


def safe_eval(
    expression: str,
    inputs: dict[str, Any] | None = None,
    timeout_seconds: int = 5,
) -> SandboxResult:
    """
    Convenience function for safe expression evaluation.

    Args:
        expression: Python expression to evaluate
        inputs: Variables to inject
        timeout_seconds: Max execution time

    Returns:
        SandboxResult
    """
    sandbox = CodeSandbox(timeout_seconds=timeout_seconds)
    return sandbox.execute_expression(expression, inputs)
