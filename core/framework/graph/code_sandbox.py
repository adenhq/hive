"""
Code Sandbox for Safe Execution of Dynamic Code.

Provides a restricted execution environment for code generated by
the external planner. This is critical for open-ended planning where
the planner can create arbitrary code actions.

Security measures:
1. Restricted builtins (no file I/O, no imports of dangerous modules)
2. Timeout enforcement
3. Memory limits (via resource module on Unix)
4. Namespace isolation
"""

import ast
import sys
import signal
import multiprocessing
from typing import Any
from dataclasses import dataclass, field
from contextlib import contextmanager

# Safe builtins whitelist
SAFE_BUILTINS = {
    # Basic types
    "True": True,
    "False": False,
    "None": None,
    "print": print,  # Allow print (will be captured)

    # Type constructors
    "bool": bool,
    "int": int,
    "float": float,
    "str": str,
    "list": list,
    "dict": dict,
    "set": set,
    "tuple": tuple,
    "frozenset": frozenset,

    # Basic functions
    "abs": abs,
    "all": all,
    "any": any,
    "bin": bin,
    "chr": chr,
    "divmod": divmod,
    "enumerate": enumerate,
    "filter": filter,
    "format": format,
    "hex": hex,
    "isinstance": isinstance,
    "issubclass": issubclass,
    "iter": iter,
    "len": len,
    "map": map,
    "max": max,
    "min": min,
    "next": next,
    "oct": oct,
    "ord": ord,
    "pow": pow,
    "range": range,
    "repr": repr,
    "reversed": reversed,
    "round": round,
    "slice": slice,
    "sorted": sorted,
    "sum": sum,
    "zip": zip,
}

# Modules that can be imported
ALLOWED_MODULES = {
    "math",
    "json",
    "re",
    "datetime",
    "collections",
    "itertools",
    "functools",
    "operator",
    "string",
    "random",
    "statistics",
    "decimal",
    "fractions",
}

# Dangerous AST nodes to block
BLOCKED_AST_NODES = {
    ast.Import,
    ast.ImportFrom,
    ast.Global,
    ast.Nonlocal,
}


class CodeSandboxError(Exception):
    """Error during sandboxed code execution."""
    pass


class TimeoutError(CodeSandboxError):
    """Code execution timed out."""
    pass


class SecurityError(CodeSandboxError):
    """Code contains potentially dangerous operations."""
    pass


@dataclass
class SandboxResult:
    """Result of sandboxed code execution."""
    success: bool
    result: Any = None
    error: str | None = None
    stdout: str = ""
    variables: dict[str, Any] = field(default_factory=dict)
    execution_time_ms: int = 0


class RestrictedImporter:
    """Custom importer that only allows whitelisted modules."""

    def __init__(self, allowed_modules: set[str]):
        self.allowed_modules = allowed_modules
        self._cache: dict[str, Any] = {}

    def __call__(self, name: str, *args, **kwargs):
        if name not in self.allowed_modules:
            raise SecurityError(f"Import of module '{name}' is not allowed")

        if name not in self._cache:
            import importlib
            self._cache[name] = importlib.import_module(name)

        return self._cache[name]


class CodeValidator:
    """Validates code for safety before execution."""

    def __init__(self, blocked_nodes: set[type] | None = None):
        self.blocked_nodes = blocked_nodes or BLOCKED_AST_NODES

    def validate(self, code: str) -> list[str]:
        """
        Validate code and return list of issues.

        Returns empty list if code is safe.
        """
        issues = []

        try:
            tree = ast.parse(code)
        except SyntaxError as e:
            return [f"Syntax error: {e}"]

        for node in ast.walk(tree):
            # Check for blocked node types
            if type(node) in self.blocked_nodes:
                issues.append(
                    f"Blocked operation: {type(node).__name__} at line {getattr(node, 'lineno', '?')}"
                )

            # Check for dangerous attribute access
            if isinstance(node, ast.Attribute):
                # Block private attributes and dangerous dunder methods
                if node.attr.startswith("_"):
                    # Allow some safe dunders if needed, but block dangerous ones explicitly
                    dangerous = {
                        "__subclasses__", "__bases__", "__mro__", "__globals__",
                        "__code__", "__closure__", "__func__", "__self__", "__module__",
                        "__dict__", "__class__"
                    }
                    if node.attr in dangerous or (node.attr.startswith("_") and not node.attr.startswith("__")):
                        issues.append(
                            f"Access to restricted attribute '{node.attr}' at line {node.lineno}"
                        )

            # Check for exec/eval calls
            if isinstance(node, ast.Call):
                if isinstance(node.func, ast.Name):
                    if node.func.id in ("exec", "eval", "compile", "__import__"):
                        issues.append(
                            f"Blocked function call: {node.func.id} at line {node.lineno}"
                        )

        return issues


class CodeSandbox:
    """
    Sandboxed environment for executing dynamic code.

    Usage:
        sandbox = CodeSandbox(timeout_seconds=5)
        result = sandbox.execute(
            code="x = 1 + 2\\nresult = x * 3",
            inputs={"multiplier": 2},
        )
        if result.success:
            print(result.variables["result"])  # 6
    """

    def __init__(
        self,
        timeout_seconds: int = 10,
        memory_limit_mb: int = 512,
        allowed_modules: set[str] | None = None,
        safe_builtins: dict[str, Any] | None = None,
    ):
        self.timeout_seconds = timeout_seconds
        self.memory_limit_mb = memory_limit_mb
        self.allowed_modules = allowed_modules or ALLOWED_MODULES
        self.safe_builtins = safe_builtins or SAFE_BUILTINS
        self.validator = CodeValidator()
        self.importer = RestrictedImporter(self.allowed_modules)

    def _set_memory_limit(self):
        """Set memory limit for the current process (Unix only)."""
        try:
            import resource
            # Convert MB to bytes
            limit = self.memory_limit_mb * 1024 * 1024
            resource.setrlimit(resource.RLIMIT_AS, (limit, limit))
        except ImportError:
            # Not available on Windows
            pass
        except Exception as e:
            # Log but don't fail if we can't set limits
            pass

    @contextmanager
    def _timeout_context(self, seconds: int):
        """Context manager for timeout enforcement."""
        def handler(signum, frame):
            raise TimeoutError(f"Code execution timed out after {seconds} seconds")

        # Only works on Unix-like systems
        if hasattr(signal, 'SIGALRM'):
            old_handler = signal.signal(signal.SIGALRM, handler)
            signal.alarm(seconds)
            try:
                yield
            finally:
                signal.alarm(0)
                signal.signal(signal.SIGALRM, old_handler)
        else:
            # Windows: no timeout support, just execute
            yield

    def _create_namespace(self, inputs: dict[str, Any]) -> dict[str, Any]:
        """Create isolated namespace for code execution."""
        namespace = {
            "__builtins__": dict(self.safe_builtins),
            "__import__": self.importer,
        }

        # Add input variables
        namespace.update(inputs)

        return namespace

    def execute(
        self,
        code: str,
        inputs: dict[str, Any] | None = None,
        extract_vars: list[str] | None = None,
    ) -> SandboxResult:
        """
        Execute code in sandbox.

        Args:
            code: Python code to execute
            inputs: Variables to inject into namespace
            extract_vars: Variable names to extract from namespace after execution

        Returns:
            SandboxResult with execution outcome
        """
        import time

        inputs = inputs or {}
        extract_vars = extract_vars or []

        # Validate code first
        issues = self.validator.validate(code)
        if issues:
            return SandboxResult(
                success=False,
                error=f"Code validation failed: {'; '.join(issues)}",
            )

        # On Windows, use multiprocessing for timeout support
        if sys.platform == "win32":
            return self._execute_windows(code, inputs, extract_vars)

        # On Unix, use signal-based timeout and resource limits
        return self._execute_unix(code, inputs, extract_vars)

    def _execute_unix(
        self,
        code: str,
        inputs: dict[str, Any],
        extract_vars: list[str],
    ) -> SandboxResult:
        """Execute code on Unix with signal-based timeout."""
        import time
        import io

        # Create isolated namespace
        namespace = self._create_namespace(inputs)

        # Capture stdout
        old_stdout = sys.stdout
        sys.stdout = captured_stdout = io.StringIO()

        start_time = time.time()

        try:
            # Set memory limit
            self._set_memory_limit()

            with self._timeout_context(self.timeout_seconds):
                # Compile and execute
                compiled = compile(code, "<sandbox>", "exec")
                exec(compiled, namespace)

            execution_time_ms = int((time.time() - start_time) * 1000)

            # Extract results (same logic as before)
            return self._extract_results(
                namespace, captured_stdout, execution_time_ms, extract_vars, inputs
            )

        except TimeoutError as e:
            return SandboxResult(
                success=False,
                error=str(e),
                execution_time_ms=self.timeout_seconds * 1000,
            )
        except SecurityError as e:
            return SandboxResult(
                success=False,
                error=f"Security violation: {e}",
                execution_time_ms=int((time.time() - start_time) * 1000),
            )
        except Exception as e:
            return SandboxResult(
                success=False,
                error=f"{type(e).__name__}: {e}",
                stdout=captured_stdout.getvalue(),
                execution_time_ms=int((time.time() - start_time) * 1000),
            )
        finally:
            sys.stdout = old_stdout

    def _execute_windows(
        self,
        code: str,
        inputs: dict[str, Any],
        extract_vars: list[str],
    ) -> SandboxResult:
        """Execute code on Windows using multiprocessing for timeout."""
        import time
        
        # We need a queue to get results back
        queue = multiprocessing.Queue()
        
        # Define target function for process
        def target(q, c, i, e_vars):
            try:
                # Redirect stdout inside process
                import io
                sys.stdout = captured = io.StringIO()
                
                # Create namespace and execute
                ns = self._create_namespace(i)
                exec(c, ns)
                
                # Extract results
                res = self._extract_results(ns, captured, 0, e_vars, i)
                q.put(res)
            except Exception as e:
                q.put(SandboxResult(success=False, error=str(e)))

        # Start process
        start_time = time.time()
        p = multiprocessing.Process(target=target, args=(queue, code, inputs, extract_vars))
        p.start()
        
        # Wait with timeout
        p.join(self.timeout_seconds)
        
        execution_time_ms = int((time.time() - start_time) * 1000)
        
        if p.is_alive():
            p.terminate()
            p.join()
            return SandboxResult(
                success=False, 
                error=f"Code execution timed out after {self.timeout_seconds} seconds",
                execution_time_ms=execution_time_ms
            )
            
        if not queue.empty():
            result = queue.get()
            result.execution_time_ms = execution_time_ms
            return result
            
        return SandboxResult(
            success=False, 
            error="Process crashed or returned no result",
            execution_time_ms=execution_time_ms
        )

    def _extract_results(
        self, 
        namespace: dict, 
        stdout: Any, 
        exec_time: int, 
        extract_vars: list[str],
        inputs: dict
    ) -> SandboxResult:
        """Helper to extract variables from namespace."""
        extracted = {}
        for var in extract_vars:
            if var in namespace:
                extracted[var] = namespace[var]

        for key, value in namespace.items():
            if (
                key not in inputs
                and key not in self.safe_builtins
                and not key.startswith("_")
            ):
                extracted[key] = value

        return SandboxResult(
            success=True,
            result=namespace.get("result"),
            stdout=stdout.getvalue(),
            variables=extracted,
            execution_time_ms=exec_time,
        )

    def execute_expression(
        self,
        expression: str,
        inputs: dict[str, Any] | None = None,
    ) -> SandboxResult:
        """
        Execute a single expression and return its value.

        Simpler than execute() - just evaluates one expression.
        """
        inputs = inputs or {}

        # Validate
        try:
            ast.parse(expression, mode="eval")
        except SyntaxError as e:
            return SandboxResult(success=False, error=f"Syntax error: {e}")

        namespace = self._create_namespace(inputs)

        try:
            with self._timeout_context(self.timeout_seconds):
                result = eval(expression, namespace)

            return SandboxResult(success=True, result=result)

        except Exception as e:
            return SandboxResult(
                success=False,
                error=f"{type(e).__name__}: {e}",
            )


# Singleton instance with default settings
default_sandbox = CodeSandbox()


def safe_exec(
    code: str,
    inputs: dict[str, Any] | None = None,
    timeout_seconds: int = 10,
) -> SandboxResult:
    """
    Convenience function for safe code execution.

    Args:
        code: Python code to execute
        inputs: Variables to inject
        timeout_seconds: Max execution time

    Returns:
        SandboxResult
    """
    sandbox = CodeSandbox(timeout_seconds=timeout_seconds)
    return sandbox.execute(code, inputs)


def safe_eval(
    expression: str,
    inputs: dict[str, Any] | None = None,
    timeout_seconds: int = 5,
) -> SandboxResult:
    """
    Convenience function for safe expression evaluation.

    Args:
        expression: Python expression to evaluate
        inputs: Variables to inject
        timeout_seconds: Max execution time

    Returns:
        SandboxResult
    """
    sandbox = CodeSandbox(timeout_seconds=timeout_seconds)
    return sandbox.execute_expression(expression, inputs)
